<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="WANG Hengze">

<title>Black-Litterman Allocation Model</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Projet_Black-Litterman_files/libs/clipboard/clipboard.min.js"></script>
<script src="Projet_Black-Litterman_files/libs/quarto-html/quarto.js"></script>
<script src="Projet_Black-Litterman_files/libs/quarto-html/popper.min.js"></script>
<script src="Projet_Black-Litterman_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Projet_Black-Litterman_files/libs/quarto-html/anchor.min.js"></script>
<link href="Projet_Black-Litterman_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Projet_Black-Litterman_files/libs/quarto-html/quarto-syntax-highlighting-d4d76bf8491c20bad77d141916dc28e1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Projet_Black-Litterman_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Projet_Black-Litterman_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Projet_Black-Litterman_files/libs/bootstrap/bootstrap-e1b8f6072ce5bcf5e382855184d0844f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="@media print {
  h2 {
    page-break-before: always;
  }
  p {
    page-break-inside: avoid;
  }
  .page {
    page-break-after: always;
    margin-bottom: 0;
    padding-bottom: 0;
  h1, h2, h3 {
    page-break-after: avoid;    // 避免标题后立即分页
  }

  table {
    page-break-inside: avoid;   // 避免表格被分页打断
  }

  figure {
    page-break-inside: avoid;   // 避免图片被分页打断
  }

  pre {
    page-break-inside: avoid;   // 避免代码块被分页打断
  }

  ul, ol {
    page-break-inside: avoid;   // 避免列表被分页打断
  }
}
  }
}
@page {
  margin: 1in;
}
body {
  max-width: 800px;
  margin: auto;
  line-height: 1.5;
}">
</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#le-modèle-de-markowitz-théorie-et-limites" id="toc-le-modèle-de-markowitz-théorie-et-limites" class="nav-link" data-scroll-target="#le-modèle-de-markowitz-théorie-et-limites">2. Le Modèle de Markowitz : Théorie et Limites</a>
  <ul class="collapse">
  <li><a href="#fondements-du-modèle" id="toc-fondements-du-modèle" class="nav-link" data-scroll-target="#fondements-du-modèle">2.1 Fondements du modèle</a></li>
  <li><a href="#risque-et-dominance-selon-markowitz" id="toc-risque-et-dominance-selon-markowitz" class="nav-link" data-scroll-target="#risque-et-dominance-selon-markowitz">2.2 Risque et dominance selon Markowitz</a></li>
  <li><a href="#résultats-clés-frontière-efficiente" id="toc-résultats-clés-frontière-efficiente" class="nav-link" data-scroll-target="#résultats-clés-frontière-efficiente">2.3 Résultats clés : frontière efficiente</a></li>
  <li><a href="#limites-pratiques-du-modèle-de-markowitz" id="toc-limites-pratiques-du-modèle-de-markowitz" class="nav-link" data-scroll-target="#limites-pratiques-du-modèle-de-markowitz">2.4 Limites pratiques du modèle de Markowitz</a></li>
  </ul></li>
  <li><a href="#le-modèle-de-black-litterman-théorie-et-avantages" id="toc-le-modèle-de-black-litterman-théorie-et-avantages" class="nav-link" data-scroll-target="#le-modèle-de-black-litterman-théorie-et-avantages">3. Le Modèle de Black-Litterman : Théorie et Avantages</a>
  <ul class="collapse">
  <li><a href="#introduction-et-motivations" id="toc-introduction-et-motivations" class="nav-link" data-scroll-target="#introduction-et-motivations">3.1 Introduction et motivations</a></li>
  <li><a href="#cadre-théorique-du-modèle" id="toc-cadre-théorique-du-modèle" class="nav-link" data-scroll-target="#cadre-théorique-du-modèle">3.2 Cadre théorique du modèle</a></li>
  <li><a href="#avantages-du-modèle-black-litterman" id="toc-avantages-du-modèle-black-litterman" class="nav-link" data-scroll-target="#avantages-du-modèle-black-litterman">3.3 Avantages du modèle Black-Litterman</a></li>
  </ul></li>
  <li><a href="#mise-en-œuvre-pratique-du-modèle-black-litterman" id="toc-mise-en-œuvre-pratique-du-modèle-black-litterman" class="nav-link" data-scroll-target="#mise-en-œuvre-pratique-du-modèle-black-litterman">4. Mise en œuvre pratique du modèle Black-Litterman</a>
  <ul class="collapse">
  <li><a href="#sélection-et-préparation-des-données" id="toc-sélection-et-préparation-des-données" class="nav-link" data-scroll-target="#sélection-et-préparation-des-données">4.1 Sélection et préparation des données</a></li>
  <li><a href="#calcul-des-rendements-historiques-et-de-la-matrice-de-covariance" id="toc-calcul-des-rendements-historiques-et-de-la-matrice-de-covariance" class="nav-link" data-scroll-target="#calcul-des-rendements-historiques-et-de-la-matrice-de-covariance">4.2 Calcul des rendements historiques et de la matrice de covariance</a></li>
  <li><a href="#estimation-des-rendements-déquilibre-du-marché" id="toc-estimation-des-rendements-déquilibre-du-marché" class="nav-link" data-scroll-target="#estimation-des-rendements-déquilibre-du-marché">4.3 Estimation des rendements d’équilibre du marché</a></li>
  <li><a href="#incorporation-des-vues-subjectives" id="toc-incorporation-des-vues-subjectives" class="nav-link" data-scroll-target="#incorporation-des-vues-subjectives">4.4 Incorporation des vues subjectives</a></li>
  <li><a href="#optimisation-du-portefeuille" id="toc-optimisation-du-portefeuille" class="nav-link" data-scroll-target="#optimisation-du-portefeuille">4.5 Optimisation du portefeuille</a></li>
  <li><a href="#évaluation-et-comparaison-des-résultats" id="toc-évaluation-et-comparaison-des-résultats" class="nav-link" data-scroll-target="#évaluation-et-comparaison-des-résultats">4.6 Évaluation et comparaison des résultats</a></li>
  </ul></li>
  <li><a href="#analyse-comparative-des-performances-du-portefeuille" id="toc-analyse-comparative-des-performances-du-portefeuille" class="nav-link" data-scroll-target="#analyse-comparative-des-performances-du-portefeuille">5. Analyse comparative des performances du portefeuille</a>
  <ul class="collapse">
  <li><a href="#indicateurs-clés-analysés" id="toc-indicateurs-clés-analysés" class="nav-link" data-scroll-target="#indicateurs-clés-analysés">5.1 Indicateurs clés analysés</a></li>
  <li><a href="#résultats-observés" id="toc-résultats-observés" class="nav-link" data-scroll-target="#résultats-observés">5.2 Résultats observés</a></li>
  <li><a href="#interprétation" id="toc-interprétation" class="nav-link" data-scroll-target="#interprétation">5.3 Interprétation</a></li>
  </ul></li>
  <li><a href="#vers-un-modèle-black-litterman-dynamique" id="toc-vers-un-modèle-black-litterman-dynamique" class="nav-link" data-scroll-target="#vers-un-modèle-black-litterman-dynamique">6. Vers un modèle Black-Litterman dynamique</a></li>
  <li><a href="#passage-dun-modèle-statique-à-un-modèle-dynamique" id="toc-passage-dun-modèle-statique-à-un-modèle-dynamique" class="nav-link" data-scroll-target="#passage-dun-modèle-statique-à-un-modèle-dynamique">7. Passage d’un modèle statique à un modèle dynamique</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Black-Litterman Allocation Model</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>WANG Hengze </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<div id="43db0131" class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ---</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># title: "Black-Litterman Allocation Model"</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># author: "WANG Hengze"</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># format:</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">#   pdf:</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">#     documentclass: report</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">#     toc: true</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">#     number-sections: true</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">#     pdf-engine: xelatex</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">#     include-in-header: </span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">#       text: |</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">#         \usepackage{fancyhdr}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">#         \pagestyle{fancy}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co">#         \fancyhf{}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co">#         \lhead{B-L Model}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co">#         \rhead{\leftmark}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co">#         \cfoot{\thepage}</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co">#         \usepackage{amsmath}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co">#         \usepackage{amssymb}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co">#         \usepackage{graphicx}</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="co">#         \usepackage{booktabs}</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="co">#         \usepackage{longtable}</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co">#         \usepackage{float}</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co">#         \usepackage{hyperref}</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co">#     mainfont: "Palatino"</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co">#     fontsize: 11pt</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="co">#     geometry: margin=1in</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="co"># ---</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>La gestion d’un portefeuille d’actifs financiers constitue un enjeu central pour les investisseurs, qu’ils soient individuels ou institutionnels. Un portefeuille est une combinaison stratégique d’actifs financiers diversifiés, tels que des actions, des obligations, des matières premières ou d’autres types d’investissements. L’objectif principal d’une telle composition est de maximiser le rendement tout en minimisant le risque, conformément au profil de risque et aux objectifs de l’investisseur.</p>
<p>Le choix des actifs et, plus particulièrement, la pondération qui leur est attribuée au sein du portefeuille, influence directement sa performance et son niveau de risque. Cependant, les modèles classiques de gestion de portefeuille, comme le modèle de Markowitz, rencontrent souvent des limites pratiques, notamment en raison de l’instabilité des poids optimaux résultant d’estimations imprécises des paramètres nécessaires (rendements attendus et matrice de covariance).</p>
<p>Face à ces défis, le modèle Black-Litterman, développé par Fischer Black et Robert Litterman au début des années 1990, apporte une réponse innovante. En combinant les attentes implicites du marché avec les opinions subjectives de l’investisseur selon une approche bayésienne, ce modèle offre une solution plus robuste et réaliste pour la gestion d’actifs.</p>
<p>L’objectif de ce projet est double : d’une part, présenter une dérivation théorique complète du modèle Black-Litterman, et d’autre part, implémenter numériquement ce modèle en utilisant Python, accompagné d’une analyse comparative détaillée avec d’autres approches classiques, comme celle de Markowitz. Ce rapport, rédigé à l’aide de Quarto dans Jupyter Notebook, permettra de mieux comprendre les forces et les limites du modèle Black-Litterman, ainsi que ses applications pratiques dans un contexte d’investissement réel.</p>
</section>
<section id="le-modèle-de-markowitz-théorie-et-limites" class="level2">
<h2 class="anchored" data-anchor-id="le-modèle-de-markowitz-théorie-et-limites">2. Le Modèle de Markowitz : Théorie et Limites</h2>
<section id="fondements-du-modèle" class="level3">
<h3 class="anchored" data-anchor-id="fondements-du-modèle">2.1 Fondements du modèle</h3>
<p>Le modèle de Markowitz, également appelé modèle de la moyenne-variance, a été introduit par Harry Markowitz en 1952. Il constitue la pierre angulaire de la théorie moderne du portefeuille. L’idée centrale repose sur l’équilibre entre rendement espéré et risque associé à un portefeuille, ce dernier étant fortement influencé par la corrélation entre les actifs.</p>
<p>Formellement, le rendement attendu d’un portefeuille <span class="math inline">R_p</span> est exprimé comme la combinaison pondérée des rendements espérés individuels des actifs. En notant <span class="math inline">\mu \in \mathbb{R}^n</span> le vecteur des rendements espérés des actifs et <span class="math inline">\mathbf{w} \in \mathbb{R}^n</span> le vecteur des poids attribués à chaque actif dans le portefeuille, nous obtenons : <span class="math display">\mathbb{E}[R_p] = \mathbf{w}^\top \mu</span></p>
<p>La variance du portefeuille, quantifiant le risque associé, dépend de la matrice de covariance <span class="math inline">\Sigma \in \mathbb{R}^{n \times n}</span> des rendements des actifs. Elle est définie par : <span class="math display">\text{Var}(R_p) = \mathbf{w}^\top \Sigma \mathbf{w}</span></p>
<p>Ces formules constituent le socle mathématique des décisions d’investissement, où l’investisseur rationnel vise à minimiser le risque pour un rendement fixé, à maximiser le rendement pour un risque déterminé, ou à maximiser le ratio de Sharpe : <span class="math display">\text{Sharpe}(\mathbf{w}) = \frac{\mathbf{w}^\top \mu - r_f}{\sqrt{\mathbf{w}^\top \Sigma \mathbf{w}}}</span> où <span class="math inline">r_f</span> représente le taux de rendement sans risque.</p>
</section>
<section id="risque-et-dominance-selon-markowitz" class="level3">
<h3 class="anchored" data-anchor-id="risque-et-dominance-selon-markowitz">2.2 Risque et dominance selon Markowitz</h3>
<p>Selon Markowitz, l’investisseur rationnel présente une aversion au risque, exprimée par deux hypothèses fondamentales :</p>
<ul>
<li>Si deux portefeuilles ont un rendement espéré égal, l’investisseur préférera toujours le portefeuille ayant le risque (variance) le plus faible.</li>
<li>Si deux portefeuilles ont un niveau de risque égal, l’investisseur préférera toujours le portefeuille ayant le rendement espéré le plus élevé.</li>
</ul>
<p>Ces principes définissent clairement les notions de dominance dans le cadre de la gestion de portefeuille.</p>
</section>
<section id="résultats-clés-frontière-efficiente" class="level3">
<h3 class="anchored" data-anchor-id="résultats-clés-frontière-efficiente">2.3 Résultats clés : frontière efficiente</h3>
<p>L’ensemble des portefeuilles répondant aux critères d’optimalité forme la <strong>frontière efficiente</strong>. Celle-ci représente toutes les combinaisons optimales possibles entre rendement et risque, surpassant toutes les autres configurations en termes de compromis rendement-risque.</p>
<p>Graphiquement, la frontière efficiente est une courbe convexe, souvent appelée « courbe moyenne-variance », représentée dans un espace ayant pour axes la volatilité (écart-type) et le rendement espéré.</p>
</section>
<section id="limites-pratiques-du-modèle-de-markowitz" class="level3">
<h3 class="anchored" data-anchor-id="limites-pratiques-du-modèle-de-markowitz">2.4 Limites pratiques du modèle de Markowitz</h3>
<p>Malgré sa robustesse théorique, le modèle présente plusieurs limites notables en pratique :</p>
<p>Premièrement, une légère modification dans les estimations des rendements espérés ou de la matrice de covariance peut entraîner une instabilité importante des poids optimaux, ce qui fragilise les décisions d’investissement.</p>
<p>Deuxièmement, le modèle suppose implicitement que les rendements suivent une distribution normale, une hypothèse rarement validée empiriquement, en raison des phénomènes fréquents d’asymétrie et de queues épaisses observées sur les marchés financiers.</p>
<p>Troisièmement, les estimations réalisées sur des périodes historiques courtes sont sujettes à des erreurs statistiques significatives, compromettant la fiabilité des résultats obtenus.</p>
<p>Enfin, le modèle original ne tient pas compte des vues ou des convictions personnelles des investisseurs, limitant ainsi sa capacité à s’adapter efficacement aux anticipations futures ou aux changements contextuels.</p>
<p>Ces contraintes opérationnelles justifient l’émergence de modèles alternatifs, tel que le modèle Black-Litterman, conçu spécifiquement pour intégrer les opinions subjectives aux données historiques objectives.</p>
</section>
</section>
<section id="le-modèle-de-black-litterman-théorie-et-avantages" class="level2">
<h2 class="anchored" data-anchor-id="le-modèle-de-black-litterman-théorie-et-avantages">3. Le Modèle de Black-Litterman : Théorie et Avantages</h2>
<section id="introduction-et-motivations" class="level3">
<h3 class="anchored" data-anchor-id="introduction-et-motivations">3.1 Introduction et motivations</h3>
<p>Le modèle Black-Litterman, développé par Fischer Black et Robert Litterman au début des années 1990, vise à pallier certaines limites pratiques du modèle de Markowitz, notamment l’instabilité des poids optimaux et l’absence d’intégration explicite des vues subjectives des investisseurs. En adoptant une approche bayésienne, ce modèle intègre efficacement les estimations implicites du marché et les convictions personnelles des investisseurs, offrant ainsi une méthode robuste et intuitive pour déterminer les allocations d’actifs optimales.</p>
</section>
<section id="cadre-théorique-du-modèle" class="level3">
<h3 class="anchored" data-anchor-id="cadre-théorique-du-modèle">3.2 Cadre théorique du modèle</h3>
<section id="estimation-des-rendements-déquilibre-implicites-du-marché" class="level4">
<h4 class="anchored" data-anchor-id="estimation-des-rendements-déquilibre-implicites-du-marché">3.2.1 Estimation des rendements d’équilibre implicites du marché</h4>
<p>Dans le cadre du modèle Black-Litterman, les rendements d’équilibre implicites (anticipés par le marché) sont initialement estimés sous l’hypothèse que les poids observés du marché sont optimaux compte tenu d’un certain niveau d’aversion au risque. Formellement, le vecteur des rendements implicites du marché <span class="math inline">\Pi</span> est obtenu par : <span class="math display">\Pi = \delta \Sigma w_{mkt}</span> où <span class="math inline">\delta</span> est le coefficient d’aversion au risque du marché, <span class="math inline">\Sigma</span> est la matrice de covariance des actifs et <span class="math inline">w_{mkt}</span> le vecteur des poids observés sur le marché.</p>
</section>
<section id="intégration-des-vues-subjectives" class="level4">
<h4 class="anchored" data-anchor-id="intégration-des-vues-subjectives">3.2.2 Intégration des vues subjectives</h4>
<p>Le modèle permet aux investisseurs d’intégrer explicitement leurs convictions subjectives sur les performances futures des actifs. Ces vues peuvent concerner des rendements absolus (par exemple, l’investisseur estime que l’actif A aura un rendement de 5 %) ou des rendements relatifs (par exemple, l’actif A surpassera l’actif B de 3 %). Formellement, les vues sont exprimées sous la forme : <span class="math display">Q = P \mu + \varepsilon, \quad \varepsilon \sim \mathcal{N}(0, \Omega)</span> où <span class="math inline">Q</span> représente le vecteur des vues, <span class="math inline">P</span> une matrice définissant les actifs concernés par ces vues, et <span class="math inline">\Omega</span> la matrice reflétant le degré d’incertitude associé à ces vues.</p>
</section>
<section id="combinaison-bayésienne-rendements-attendus-postérieurs" class="level4">
<h4 class="anchored" data-anchor-id="combinaison-bayésienne-rendements-attendus-postérieurs">3.2.3 Combinaison bayésienne : rendements attendus postérieurs</h4>
<p>L’intégration des vues subjectives avec les estimations implicites du marché s’effectue par une procédure bayésienne permettant de calculer des rendements attendus dits « postérieurs ». Formellement, les rendements attendus postérieurs <span class="math inline">\mu_{BL}</span> sont calculés selon : <span class="math display">\mu_{BL} = \left[(\tau \Sigma)^{-1} + P^\top \Omega^{-1} P\right]^{-1} \left[(\tau \Sigma)^{-1}\Pi + P^\top \Omega^{-1}Q\right]</span> où <span class="math inline">\tau</span> représente un paramètre d’incertitude lié aux estimations initiales.</p>
</section>
<section id="détermination-finale-des-poids-du-portefeuille" class="level4">
<h4 class="anchored" data-anchor-id="détermination-finale-des-poids-du-portefeuille">3.2.4 Détermination finale des poids du portefeuille</h4>
<p>Enfin, les rendements attendus postérieurs sont utilisés pour déterminer les poids optimaux du portefeuille selon la méthode traditionnelle de la moyenne-variance. Formellement, les poids optimaux <span class="math inline">w_{BL}</span> du portefeuille sont obtenus par :</p>
<p><span class="math display">w_{BL} = \frac{1}{\delta} \Sigma^{-1} \mu_{BL}</span></p>
<p>Cette procédure permet d’obtenir une allocation d’actifs robuste et adaptée aux anticipations spécifiques des investisseurs, tout en bénéficiant de la stabilité accrue apportée par le cadre bayésien.</p>
</section>
</section>
<section id="avantages-du-modèle-black-litterman" class="level3">
<h3 class="anchored" data-anchor-id="avantages-du-modèle-black-litterman">3.3 Avantages du modèle Black-Litterman</h3>
<p>Le modèle Black-Litterman présente plusieurs avantages décisifs comparativement au modèle traditionnel de Markowitz. En intégrant directement les convictions subjectives des investisseurs aux estimations objectives du marché, il permet d’obtenir des poids de portefeuille plus stables et moins sensibles aux erreurs d’estimation. Sa flexibilité intrinsèque favorise une adaptation rapide aux évolutions contextuelles du marché et aux modifications éventuelles des vues des investisseurs. Enfin, grâce à sa transparence et à son approche intuitive, le modèle Black-Litterman améliore sensiblement l’interprétabilité des résultats obtenus, facilitant ainsi les prises de décision en gestion d’actifs.</p>
</section>
</section>
<section id="mise-en-œuvre-pratique-du-modèle-black-litterman" class="level2">
<h2 class="anchored" data-anchor-id="mise-en-œuvre-pratique-du-modèle-black-litterman">4. Mise en œuvre pratique du modèle Black-Litterman</h2>
<section id="sélection-et-préparation-des-données" class="level3">
<h3 class="anchored" data-anchor-id="sélection-et-préparation-des-données">4.1 Sélection et préparation des données</h3>
<p>Pour mettre en œuvre le modèle Black-Litterman, il est nécessaire de commencer par sélectionner un ensemble pertinent d’actifs financiers. Généralement, les données historiques des prix ajustés à la clôture des actifs sélectionnés sont récupérées sur des plateformes financières, telles que Yahoo Finance, en utilisant des outils programmatiques comme Python et la bibliothèque <code>yfinance</code>. Ces données permettent d’estimer les rendements historiques et la matrice de covariance des actifs, éléments indispensables pour le modèle.</p>
</section>
<section id="calcul-des-rendements-historiques-et-de-la-matrice-de-covariance" class="level3">
<h3 class="anchored" data-anchor-id="calcul-des-rendements-historiques-et-de-la-matrice-de-covariance">4.2 Calcul des rendements historiques et de la matrice de covariance</h3>
<p>À partir des prix historiques, les rendements attendus des actifs sont généralement estimés en calculant la moyenne historique des rendements journaliers annualisés. La matrice de covariance est obtenue en calculant les covariances historiques des rendements journaliers, également annualisées. Ces calculs peuvent être réalisés efficacement avec les modules spécifiques de la bibliothèque <code>PyPortfolioOpt</code> : <code>expected_returns</code> et <code>risk_models</code>.</p>
</section>
<section id="estimation-des-rendements-déquilibre-du-marché" class="level3">
<h3 class="anchored" data-anchor-id="estimation-des-rendements-déquilibre-du-marché">4.3 Estimation des rendements d’équilibre du marché</h3>
<p>L’estimation initiale des rendements implicites du marché (rendements d’équilibre) est calculée en tenant compte des poids de marché des actifs, du niveau d’aversion au risque observé sur le marché, ainsi que de la matrice de covariance précédemment déterminée. Le coefficient d’aversion au risque du marché est généralement estimé à partir des rendements historiques du marché global, comme l’indice S&amp;P 500.</p>
</section>
<section id="incorporation-des-vues-subjectives" class="level3">
<h3 class="anchored" data-anchor-id="incorporation-des-vues-subjectives">4.4 Incorporation des vues subjectives</h3>
<p>La spécificité du modèle Black-Litterman réside dans l’intégration des vues subjectives de l’investisseur sur certains actifs ou sur des relations entre actifs. Ces vues sont quantifiées par un vecteur de rendement attendu pour chaque conviction ainsi qu’une matrice associée définissant les actifs impliqués. De plus, une matrice de confiance est utilisée pour représenter le niveau d’incertitude lié à ces convictions, généralement estimée par la méthode d’Idzorek.</p>
</section>
<section id="optimisation-du-portefeuille" class="level3">
<h3 class="anchored" data-anchor-id="optimisation-du-portefeuille">4.5 Optimisation du portefeuille</h3>
<p>Les rendements attendus postérieurs, résultant de la combinaison des estimations du marché et des vues subjectives via le modèle Black-Litterman, servent de base pour optimiser la répartition du portefeuille selon les principes du modèle de Markowitz. L’objectif typique est la maximisation du ratio de Sharpe, ce qui implique de déterminer les poids optimaux qui maximisent le rendement ajusté du risque.</p>
</section>
<section id="évaluation-et-comparaison-des-résultats" class="level3">
<h3 class="anchored" data-anchor-id="évaluation-et-comparaison-des-résultats">4.6 Évaluation et comparaison des résultats</h3>
<p>Enfin, la performance du portefeuille optimisé selon le modèle Black-Litterman peut être évaluée à l’aide d’outils d’analyse de performance financière, tels que la bibliothèque <code>quantstats</code>. Différents indicateurs, comme le rendement cumulé, la volatilité annualisée, le ratio de Sharpe, la perte maximale (drawdown) et la corrélation avec un benchmark pertinent (tel que l’indice S&amp;P 500), sont utilisés pour juger de la pertinence et de l’efficacité de l’allocation déterminée par le modèle Black-Litterman.</p>
<p>Cette approche complète permet non seulement d’appliquer rigoureusement le modèle Black-Litterman, mais également d’en apprécier les avantages pratiques en termes de stabilité et de performance dans un contexte réel d’investissement.</p>
<div id="my-code" class="cell" data-fold="true" data-execution_count="14">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Implémentation du modèle Black-Litterman avec PyPortfolioOpt et quantstats</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> yfinance <span class="im">as</span> yf</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pypfopt <span class="im">import</span> expected_returns, risk_models, BlackLittermanModel, EfficientFrontier</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pypfopt.black_litterman <span class="im">import</span> market_implied_prior_returns, market_implied_risk_aversion</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> quantstats <span class="im">as</span> qs</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> quantstats.reports <span class="im">as</span> qsr</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Téléchargement des données historiques (2 dernières années)</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>assets <span class="op">=</span> [<span class="st">"AAPL"</span>, <span class="st">"TSLA"</span>, <span class="st">"DIS"</span>, <span class="st">"AMD"</span>]</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> yf.download(assets, start<span class="op">=</span><span class="st">"2022-01-01"</span>, end<span class="op">=</span><span class="st">"2025-01-01"</span>)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Extraire les prix de clôture</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>prices <span class="op">=</span> data[<span class="st">'Close'</span>]</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Vérifier les données</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Premières lignes des prix:"</span>)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(prices.head())</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Nombre de valeurs manquantes par colonne:"</span>)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(prices.isnull().<span class="bu">sum</span>())</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>prices <span class="op">=</span> prices.dropna()</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. Estimation des paramètres du modèle de Markowitz</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> expected_returns.mean_historical_return(prices)</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> risk_models.sample_cov(prices)</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. Estimation des rendements implicites du marché (prior)</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>cap_data <span class="op">=</span> yf.download(assets, period<span class="op">=</span><span class="st">"1d"</span>)[<span class="st">'Close'</span>]</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>cap_data <span class="op">=</span> cap_data.iloc[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>cap_weights <span class="op">=</span> cap_data <span class="op">/</span> cap_data.<span class="bu">sum</span>()</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Télécharger les prix du S&amp;P 500 pour estimer l'aversion au risque</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>market_prices <span class="op">=</span> yf.download(<span class="st">"^GSPC"</span>, start<span class="op">=</span><span class="st">"2022-01-01"</span>, end<span class="op">=</span><span class="st">"2025-01-01"</span>)[<span class="st">"Close"</span>].dropna()</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>delta <span class="op">=</span> market_implied_risk_aversion(market_prices)</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>prior <span class="op">=</span> market_implied_prior_returns(cap_weights, delta, S)</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. Définition des vues subjectives</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> np.array([<span class="fl">0.05</span>, <span class="fl">0.10</span>, <span class="fl">0.15</span>])</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> np.array([</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],   <span class="co"># AAPL</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>],   <span class="co"># TSLA</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>]   <span class="co"># AMD &gt; DIS</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>confidences <span class="op">=</span> [<span class="fl">0.6</span>, <span class="fl">0.7</span>, <span class="fl">0.9</span>]</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a><span class="co"># 5. Construction du modèle Black-Litterman</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>bl <span class="op">=</span> BlackLittermanModel(</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    S, </span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>    pi<span class="op">=</span>prior, </span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>    Q<span class="op">=</span>Q, </span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>    P<span class="op">=</span>P, </span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    omega<span class="op">=</span><span class="st">'idzorek'</span>, </span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>    view_confidences<span class="op">=</span>confidences</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>mu_bl <span class="op">=</span> bl.bl_returns()</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a><span class="co"># 6. Optimisation du portefeuille</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>ef <span class="op">=</span> EfficientFrontier(mu_bl, S)</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>ef.max_sharpe()</span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> ef.clean_weights()</span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a><span class="co"># 7. Simulation du portefeuille optimisé</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>returns <span class="op">=</span> prices.pct_change().dropna()</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>bl_portfolio <span class="op">=</span> returns.dot(pd.Series(weights))</span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a><span class="co"># 8. Évaluation de la performance avec quantstats</span></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>benchmark_returns <span class="op">=</span> market_prices.pct_change().dropna()</span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>combined <span class="op">=</span> pd.concat([bl_portfolio, benchmark_returns], axis<span class="op">=</span><span class="dv">1</span>, join<span class="op">=</span><span class="st">'inner'</span>).dropna()</span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>combined.columns <span class="op">=</span> [<span class="st">'bl_portfolio'</span>, <span class="st">'benchmark'</span>]</span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a><span class="co"># S'assurer que les Series sont bien formatées</span></span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>bl_portfolio <span class="op">=</span> combined[<span class="st">'bl_portfolio'</span>].astype(<span class="bu">float</span>)</span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>benchmark <span class="op">=</span> combined[<span class="st">'benchmark'</span>].astype(<span class="bu">float</span>)</span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a><span class="co"># Générer tous les graphiques détaillés à la main (sauf daily_returns qui pose problème)</span></span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>qs.plots.returns(bl_portfolio, benchmark<span class="op">=</span>benchmark)</span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>qs.plots.drawdown(bl_portfolio)</span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>qs.plots.rolling_sharpe(bl_portfolio)</span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a>qs.plots.rolling_beta(bl_portfolio, benchmark)</span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a>qs.plots.rolling_volatility(bl_portfolio)</span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>qs.plots.monthly_heatmap(bl_portfolio)</span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a>qs.plots.histogram(bl_portfolio)</span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>[*********************100%***********************]  4 of 4 completed
[*********************100%***********************]  4 of 4 completed
[*********************100%***********************]  1 of 1 completed</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Premières lignes des prix:
Ticker            AAPL         AMD         DIS        TSLA
Date                                                      
2022-01-03  178.879898  150.240005  154.847061  399.926666
2022-01-04  176.609619  144.419998  153.829636  383.196655
2022-01-05  171.911850  136.149994  153.296249  362.706665
2022-01-06  169.042053  136.229996  154.985352  354.899994
2022-01-07  169.209122  132.000000  155.904022  342.320007

Nombre de valeurs manquantes par colonne:
Ticker
AAPL    0
AMD     0
DIS     0
TSLA    0
dtype: int64</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Projet_Black-Litterman_files/figure-html/my-code-output-3.png" id="my-code-1" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Projet_Black-Litterman_files/figure-html/my-code-output-4.png" id="my-code-2" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Projet_Black-Litterman_files/figure-html/my-code-output-5.png" id="my-code-3" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Projet_Black-Litterman_files/figure-html/my-code-output-6.png" id="my-code-4" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Projet_Black-Litterman_files/figure-html/my-code-output-7.png" id="my-code-5" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Projet_Black-Litterman_files/figure-html/my-code-output-8.png" id="my-code-6" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Projet_Black-Litterman_files/figure-html/my-code-output-9.png" id="my-code-7" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="c8d09bfd" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> quantstats <span class="im">as</span> qs</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>qs.reports.metrics(bl_portfolio, benchmark<span class="op">=</span>benchmark)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                    Benchmark    Strategy
------------------  -----------  ----------
Start Period        2022-01-04   2022-01-04
End Period          2024-12-31   2024-12-31
Risk-Free Rate      0.0%         0.0%
Time in Market      100.0%       100.0%

Cumulative Return   22.62%       -3.44%
CAGR﹪              4.82%        -0.8%

Sharpe              0.48         0.14
Prob. Sharpe Ratio  79.48%       59.38%
Sortino             0.68         0.2
Sortino/√2          0.48         0.14
Omega               1.02         1.02

Max Drawdown        -25.38%      -54.86%
Longest DD Days     744          1071

Gain/Pain Ratio     0.09         0.02
Gain/Pain (1M)      0.38         0.1

Payoff Ratio        1.0          1.01
Profit Factor       1.09         1.02
Common Sense Ratio  1.14         1.03
CPC Index           0.56         0.52
Tail Ratio          1.05         1.01
Outlier Win Ratio   4.7          2.32
Outlier Loss Ratio  5.18         2.53

MTD                 -2.5%        4.06%
3M                  2.5%         31.56%
6M                  7.71%        46.35%
YTD                 23.31%       44.98%
1Y                  23.31%       44.98%
3Y (ann.)           6.93%        4.07%
5Y (ann.)           4.82%        -0.8%
10Y (ann.)          4.82%        -0.8%
All-time (ann.)     4.82%        -0.8%

Avg. Drawdown       -2.11%       -20.79%
Avg. Drawdown Days  33           362
Recovery Factor     0.98         0.26
Ulcer Index         0.11         0.32
Serenity Index      0.12         0.02</code></pre>
</div>
</div>
</section>
</section>
<section id="analyse-comparative-des-performances-du-portefeuille" class="level2">
<h2 class="anchored" data-anchor-id="analyse-comparative-des-performances-du-portefeuille">5. Analyse comparative des performances du portefeuille</h2>
<p>Dans cette section, nous comparons la performance du portefeuille optimisé via le modèle Black-Litterman avec celle de l’indice de référence, le S&amp;P 500. Cette comparaison repose sur des indicateurs quantitatifs standards en finance, permettant d’évaluer la rentabilité, le risque et la qualité du portefeuille sur la période analysée (2022-2024).</p>
<section id="indicateurs-clés-analysés" class="level3">
<h3 class="anchored" data-anchor-id="indicateurs-clés-analysés">5.1 Indicateurs clés analysés</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 22%">
<col style="width: 16%">
<col style="width: 19%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>Indicateur</th>
<th>Portefeuille BL</th>
<th>S&amp;P 500 (Benchmark)</th>
<th>Interprétation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Rendement cumulé</td>
<td>-3.44 %</td>
<td>22.62 %</td>
<td>Performance brute sur la période</td>
</tr>
<tr class="even">
<td>Ratio de Sharpe</td>
<td>0.14</td>
<td>0.48</td>
<td>Rendement corrigé du risque</td>
</tr>
<tr class="odd">
<td>Drawdown maximal</td>
<td>-54.86 %</td>
<td>-25.38 %</td>
<td>Pire baisse enregistrée</td>
</tr>
<tr class="even">
<td>Rolling beta (moyenne)</td>
<td>≈ 1.01</td>
<td>1.00</td>
<td>Sensibilité au marché</td>
</tr>
</tbody>
</table>
<blockquote class="blockquote">
<p><em>Les valeurs sont issues de l’analyse quantstats (2022-2024).</em></p>
</blockquote>
</section>
<section id="résultats-observés" class="level3">
<h3 class="anchored" data-anchor-id="résultats-observés">5.2 Résultats observés</h3>
<p>D’après les visualisations et les rapports générés par les fonctions <code>quantstats</code>, nous notons les éléments suivants :</p>
<ul>
<li>Le <strong>rendement cumulé</strong> du portefeuille Black-Litterman est négatif (-3.44 %), en contraste avec le benchmark qui a généré +22.62 % sur la période.</li>
<li>Le portefeuille a connu un <strong>drawdown maximal significativement plus profond</strong> que celui de l’indice (-54.86 % contre -25.38 %), indiquant une forte exposition au risque baissier.</li>
<li>Le <strong>ratio de Sharpe</strong> du portefeuille (0.14) reste positif mais bien inférieur à celui du S&amp;P 500 (0.48), ce qui traduit une performance ajustée du risque relativement faible.</li>
<li>Malgré tout, certains ratios comme le <strong>payoff ratio</strong>, l’<strong>omega</strong> ou la <strong>tail ratio</strong> sont proches ou légèrement supérieurs à ceux du benchmark, ce qui suggère une distribution des gains atypique mais potentiellement exploitable.</li>
</ul>
</section>
<section id="interprétation" class="level3">
<h3 class="anchored" data-anchor-id="interprétation">5.3 Interprétation</h3>
<p>Ces résultats illustrent les limites de la stratégie Black-Litterman dans cette configuration spécifique : bien que théoriquement équilibré entre vues subjectives et attentes de marché, le portefeuille a souffert d’une mauvaise allocation ou de vues trop optimistes sur certains actifs très volatils (comme TSLA ou AMD). Cela a entraîné des pertes plus importantes que le benchmark, notamment durant les phases de stress.</p>
<p>Il serait pertinent d’envisager des ajustements tels que l’introduction de contraintes supplémentaires (ex. : plafonnement des pondérations, gestion dynamique des vues, intégration d’un facteur ESG ou qualité), ou encore une fréquence de rééquilibrage plus adaptée aux conditions de marché.</p>
</section>
</section>
<section id="vers-un-modèle-black-litterman-dynamique" class="level2">
<h2 class="anchored" data-anchor-id="vers-un-modèle-black-litterman-dynamique">6. Vers un modèle Black-Litterman dynamique</h2>
<p>Le modèle Black-Litterman présenté jusqu’ici est de nature statique : il détermine une allocation unique à partir d’un instant donné, sans tenir compte de l’évolution continue du marché. Or, dans un contexte de gestion active, il est crucial d’adapter régulièrement le portefeuille aux nouvelles informations disponibles.</p>
<p>Une extension naturelle du modèle consiste à le rendre <strong>dynamique</strong>, en procédant à un <strong>rééquilibrage périodique</strong> de l’allocation. À chaque période (par exemple, mensuelle ou trimestrielle), on :</p>
<ul>
<li>Met à jour les données de prix des actifs pour recalculer <span class="math inline">\mu</span> et <span class="math inline">\Sigma</span> ;</li>
<li>Réestime les poids implicites du marché <span class="math inline">\pi</span> à l’aide des nouvelles capitalisations boursières ;</li>
<li>Réactualise les vues (<span class="math inline">Q, P</span>), selon des signaux techniques, fondamentaux ou via des scores de confiance prédéfinis ;</li>
<li>Recalcule <span class="math inline">\mu_{BL}</span> puis optimise <span class="math inline">w_{BL}</span>.</li>
</ul>
<p>Cela permet de construire un <strong>portefeuille adaptatif</strong>, qui suit les dynamiques du marché tout en conservant la robustesse du cadre Black-Litterman. Une telle approche pourrait améliorer sensiblement la performance du portefeuille, en particulier dans des environnements volatils.</p>
<p>Dans la suite du travail, une expérimentation sera menée sur l’horizon 2022–2024 avec un rééquilibrage trimestriel, afin d’évaluer dans quelle mesure le modèle dynamique surpasse la version statique précédemment étudiée.</p>
<div id="f0896614" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Modèle Black-Litterman dynamique avec rééquilibrage trimestriel (amélioré avec contraintes et vues dynamiques + contrôle de drawdown)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> yfinance <span class="im">as</span> yf</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pypfopt <span class="im">import</span> expected_returns, risk_models, EfficientFrontier</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pypfopt.black_litterman <span class="im">import</span> BlackLittermanModel, market_implied_prior_returns, market_implied_risk_aversion</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">'once'</span>, category<span class="op">=</span><span class="pp">UserWarning</span>, module<span class="op">=</span><span class="st">'pypfopt'</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Paramètres initiaux</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>assets <span class="op">=</span> [</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">"AAPL"</span>, <span class="st">"MSFT"</span>, <span class="st">"GOOGL"</span>, <span class="st">"AMZN"</span>, <span class="st">"META"</span>, <span class="st">"TSLA"</span>, <span class="st">"NVDA"</span>, <span class="st">"UNH"</span>, <span class="st">"JPM"</span>, <span class="st">"XOM"</span>,</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">"LLY"</span>, <span class="st">"V"</span>, <span class="st">"HD"</span>, <span class="st">"MRK"</span>, <span class="st">"PEP"</span>, <span class="st">"ABBV"</span>, <span class="st">"PG"</span>, <span class="st">"CVX"</span>, <span class="st">"COST"</span>, <span class="st">"AVGO"</span>,</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">"BAC"</span>, <span class="st">"WMT"</span>, <span class="st">"ADBE"</span>, <span class="st">"CRM"</span>, <span class="st">"KO"</span>, <span class="st">"NFLX"</span>, <span class="st">"TMO"</span>, <span class="st">"INTC"</span>, <span class="st">"ABT"</span>, <span class="st">"MCD"</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>start_date <span class="op">=</span> <span class="st">"2022-01-01"</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>end_date <span class="op">=</span> <span class="st">"2024-12-31"</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>rebalance_freq <span class="op">=</span> <span class="st">"Q"</span>  <span class="co"># Quarterly</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>max_drawdown_threshold <span class="op">=</span> <span class="op">-</span><span class="fl">0.3</span>  <span class="co"># tolérance max à une perte de -30 %</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Téléchargement des prix (close) corrigés automatiquement</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Télécharger les prix</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>raw_data <span class="op">=</span> yf.download(assets, start<span class="op">=</span>start_date, end<span class="op">=</span>end_date, auto_adjust<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>price_data <span class="op">=</span> raw_data[<span class="st">'Close'</span>] <span class="cf">if</span> <span class="bu">isinstance</span>(raw_data.columns, pd.MultiIndex) <span class="cf">else</span> raw_data</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Détection des colonnes avec trop de NaNs (&gt;10%)</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>nas <span class="op">=</span> price_data.isna().mean()</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>price_data <span class="op">=</span> price_data.loc[:, nas <span class="op">&lt;=</span> <span class="fl">0.1</span>]  <span class="co"># Conserver seulement les actifs fiables</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Affichage des actifs finaux retenus</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>assets <span class="op">=</span> price_data.columns.tolist()</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Actifs retenus après contrôle qualité (</span><span class="sc">{</span><span class="bu">len</span>(assets)<span class="sc">}</span><span class="ss">):"</span>, assets)</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Suppression des dates incomplètes</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>date_threshold <span class="op">=</span> <span class="bu">len</span>(assets) <span class="op">*</span> <span class="fl">0.9</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>price_data <span class="op">=</span> price_data.dropna(thresh<span class="op">=</span><span class="bu">int</span>(date_threshold), axis<span class="op">=</span><span class="dv">0</span>).dropna(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>raw_data <span class="op">=</span> yf.download(assets, start<span class="op">=</span>start_date, end<span class="op">=</span>end_date, auto_adjust<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>price_data <span class="op">=</span> raw_data[<span class="st">'Close'</span>] <span class="cf">if</span> <span class="bu">isinstance</span>(raw_data.columns, pd.MultiIndex) <span class="cf">else</span> raw_data</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>price_data <span class="op">=</span> price_data.dropna()</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Téléchargement du benchmark (S&amp;P 500) - également auto_adjust</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>benchmark_prices <span class="op">=</span> yf.download(<span class="st">"^GSPC"</span>, start<span class="op">=</span>start_date, end<span class="op">=</span>end_date, auto_adjust<span class="op">=</span><span class="va">True</span>)[<span class="st">'Close'</span>]</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>benchmark <span class="op">=</span> benchmark_prices.pct_change().dropna()</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. Construction d'un portefeuille dynamique</span></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>portfolio_history <span class="op">=</span> []</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>portfolio_value <span class="op">=</span> <span class="fl">1.0</span>  <span class="co"># valeur initiale normalisée</span></span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>cum_returns <span class="op">=</span> []</span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> date, sub_prices <span class="kw">in</span> price_data.resample(<span class="st">'QE'</span> <span class="cf">if</span> rebalance_freq <span class="op">==</span> <span class="st">'Q'</span> <span class="cf">else</span> rebalance_freq):</span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(sub_prices) <span class="op">&lt;</span> <span class="dv">60</span>:</span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>    returns <span class="op">=</span> sub_prices.pct_change().dropna()</span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>    mu <span class="op">=</span> expected_returns.mean_historical_return(sub_prices)</span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> risk_models.sample_cov(sub_prices)</span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>    cap_weights <span class="op">=</span> pd.Series([<span class="dv">1</span><span class="op">/</span><span class="bu">len</span>(assets)] <span class="op">*</span> <span class="bu">len</span>(assets), index<span class="op">=</span>assets)</span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>    delta <span class="op">=</span> market_implied_risk_aversion(benchmark_prices)</span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a>    prior <span class="op">=</span> market_implied_prior_returns(cap_weights, delta, S)</span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Vues dynamiques simulées : plus les actifs sont volatils, plus on est prudent</span></span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a>    vol <span class="op">=</span> returns.std()</span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a>    Q <span class="op">=</span> np.clip(mu.values <span class="op">-</span> vol.values <span class="op">*</span> <span class="fl">0.5</span>, <span class="op">-</span><span class="fl">0.1</span>, <span class="fl">0.1</span>)</span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> np.eye(<span class="bu">len</span>(assets))  <span class="co"># une vue par actif (vue absolue)</span></span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a>    confidences <span class="op">=</span> np.clip(<span class="dv">1</span> <span class="op">-</span> vol.values <span class="op">/</span> vol.<span class="bu">max</span>(), <span class="fl">0.1</span>, <span class="fl">0.9</span>)</span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a>    bl <span class="op">=</span> BlackLittermanModel(S, pi<span class="op">=</span>prior, Q<span class="op">=</span>Q, P<span class="op">=</span>P, omega<span class="op">=</span><span class="st">"idzorek"</span>, view_confidences<span class="op">=</span>confidences)</span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a>    bl_mu <span class="op">=</span> bl.bl_returns()</span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a>    ef <span class="op">=</span> EfficientFrontier(bl_mu, S)</span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> cvxpy <span class="im">as</span> cp</span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a>    ef.add_objective(cp.norm1)</span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a>    ef.add_constraint(<span class="kw">lambda</span> w: w <span class="op">&lt;=</span> <span class="fl">0.4</span>)</span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a>    ef.add_constraint(<span class="kw">lambda</span> w: w <span class="op">&gt;=</span> <span class="fl">0.0</span>)</span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">=</span> ef.max_sharpe()</span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a>    cleaned_weights <span class="op">=</span> ef.clean_weights()</span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-83"><a href="#cb7-83" aria-hidden="true" tabindex="-1"></a>    next_window <span class="op">=</span> price_data.loc[date:].iloc[<span class="dv">1</span>:<span class="dv">65</span>]  <span class="co"># ~3 mois de données</span></span>
<span id="cb7-84"><a href="#cb7-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> next_window.empty:</span>
<span id="cb7-85"><a href="#cb7-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb7-86"><a href="#cb7-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-87"><a href="#cb7-87" aria-hidden="true" tabindex="-1"></a>    daily_returns <span class="op">=</span> next_window.pct_change().dropna()</span>
<span id="cb7-88"><a href="#cb7-88" aria-hidden="true" tabindex="-1"></a>    weighted_returns <span class="op">=</span> daily_returns.dot(pd.Series(cleaned_weights))</span>
<span id="cb7-89"><a href="#cb7-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-90"><a href="#cb7-90" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Contrôle de drawdown : on n'investit que si drawdown &lt; seuil</span></span>
<span id="cb7-91"><a href="#cb7-91" aria-hidden="true" tabindex="-1"></a>    cumulative <span class="op">=</span> (<span class="dv">1</span> <span class="op">+</span> weighted_returns).cumprod()</span>
<span id="cb7-92"><a href="#cb7-92" aria-hidden="true" tabindex="-1"></a>    rolling_max <span class="op">=</span> cumulative.cummax()</span>
<span id="cb7-93"><a href="#cb7-93" aria-hidden="true" tabindex="-1"></a>    drawdown <span class="op">=</span> (cumulative <span class="op">-</span> rolling_max) <span class="op">/</span> rolling_max</span>
<span id="cb7-94"><a href="#cb7-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-95"><a href="#cb7-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> drawdown.<span class="bu">min</span>() <span class="op">&lt;</span> max_drawdown_threshold:</span>
<span id="cb7-96"><a href="#cb7-96" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"[ATTENTION] Rééquilibrage à </span><span class="sc">{</span>date<span class="sc">.</span>date()<span class="sc">}</span><span class="ss"> ignoré : drawdown potentiel trop élevé"</span>)</span>
<span id="cb7-97"><a href="#cb7-97" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb7-98"><a href="#cb7-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-99"><a href="#cb7-99" aria-hidden="true" tabindex="-1"></a>    portfolio_history.append(weighted_returns)</span>
<span id="cb7-100"><a href="#cb7-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-101"><a href="#cb7-101" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. Construction de la série temporelle finale</span></span>
<span id="cb7-102"><a href="#cb7-102" aria-hidden="true" tabindex="-1"></a>portfolio_dynamic <span class="op">=</span> pd.concat(portfolio_history).sort_index()</span>
<span id="cb7-103"><a href="#cb7-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-104"><a href="#cb7-104" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. Nettoyage des données et analyse</span></span>
<span id="cb7-105"><a href="#cb7-105" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb7-106"><a href="#cb7-106" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> quantstats <span class="im">as</span> qs</span>
<span id="cb7-107"><a href="#cb7-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-108"><a href="#cb7-108" aria-hidden="true" tabindex="-1"></a><span class="co"># 4.1 Nettoyage des données : traitement des index dupliqués</span></span>
<span id="cb7-109"><a href="#cb7-109" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">=== Rapport de nettoyage des données ==="</span>)</span>
<span id="cb7-110"><a href="#cb7-110" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Vérification des index dupliqués avant nettoyage :"</span>)</span>
<span id="cb7-111"><a href="#cb7-111" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Nombre d'index dupliqués dans le Portfolio : </span><span class="sc">{</span>portfolio_dynamic<span class="sc">.</span>index<span class="sc">.</span>duplicated()<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-112"><a href="#cb7-112" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Nombre d'index dupliqués dans le Benchmark : </span><span class="sc">{</span>benchmark<span class="sc">.</span>index<span class="sc">.</span>duplicated()<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-113"><a href="#cb7-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-114"><a href="#cb7-114" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> portfolio_dynamic.index.duplicated().<span class="bu">any</span>():</span>
<span id="cb7-115"><a href="#cb7-115" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Dates des index dupliqués :"</span>)</span>
<span id="cb7-116"><a href="#cb7-116" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(portfolio_dynamic.index[portfolio_dynamic.index.duplicated()].unique())</span>
<span id="cb7-117"><a href="#cb7-117" aria-hidden="true" tabindex="-1"></a>    portfolio_dynamic <span class="op">=</span> portfolio_dynamic[<span class="op">~</span>portfolio_dynamic.index.duplicated(keep<span class="op">=</span><span class="st">'first'</span>)]</span>
<span id="cb7-118"><a href="#cb7-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-119"><a href="#cb7-119" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> benchmark.index.duplicated().<span class="bu">any</span>():</span>
<span id="cb7-120"><a href="#cb7-120" aria-hidden="true" tabindex="-1"></a>    benchmark <span class="op">=</span> benchmark[<span class="op">~</span>benchmark.index.duplicated(keep<span class="op">=</span><span class="st">'first'</span>)]</span>
<span id="cb7-121"><a href="#cb7-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-122"><a href="#cb7-122" aria-hidden="true" tabindex="-1"></a><span class="co"># Alignement des séries temporelles</span></span>
<span id="cb7-123"><a href="#cb7-123" aria-hidden="true" tabindex="-1"></a>common_index <span class="op">=</span> portfolio_dynamic.index.intersection(benchmark.index)</span>
<span id="cb7-124"><a href="#cb7-124" aria-hidden="true" tabindex="-1"></a>portfolio_dynamic <span class="op">=</span> portfolio_dynamic.loc[common_index]</span>
<span id="cb7-125"><a href="#cb7-125" aria-hidden="true" tabindex="-1"></a>benchmark <span class="op">=</span> benchmark.loc[common_index]</span>
<span id="cb7-126"><a href="#cb7-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-127"><a href="#cb7-127" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Vérification après nettoyage :"</span>)</span>
<span id="cb7-128"><a href="#cb7-128" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Nombre de points de données Portfolio : </span><span class="sc">{</span><span class="bu">len</span>(portfolio_dynamic)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-129"><a href="#cb7-129" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Nombre de points de données Benchmark : </span><span class="sc">{</span><span class="bu">len</span>(benchmark)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-130"><a href="#cb7-130" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Période d'analyse : du </span><span class="sc">{</span>portfolio_dynamic<span class="sc">.</span>index[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> au </span><span class="sc">{</span>portfolio_dynamic<span class="sc">.</span>index[<span class="op">-</span><span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-131"><a href="#cb7-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-132"><a href="#cb7-132" aria-hidden="true" tabindex="-1"></a><span class="co"># 4.2 Visualisation des résultats</span></span>
<span id="cb7-133"><a href="#cb7-133" aria-hidden="true" tabindex="-1"></a>qs.plots.returns(portfolio_dynamic, benchmark<span class="op">=</span>benchmark)</span>
<span id="cb7-134"><a href="#cb7-134" aria-hidden="true" tabindex="-1"></a>qs.plots.drawdown(portfolio_dynamic)</span>
<span id="cb7-135"><a href="#cb7-135" aria-hidden="true" tabindex="-1"></a>qs.plots.rolling_sharpe(portfolio_dynamic)</span>
<span id="cb7-136"><a href="#cb7-136" aria-hidden="true" tabindex="-1"></a>qs.plots.rolling_beta(portfolio_dynamic, benchmark<span class="op">=</span>benchmark)</span>
<span id="cb7-137"><a href="#cb7-137" aria-hidden="true" tabindex="-1"></a>qs.plots.rolling_volatility(portfolio_dynamic)</span>
<span id="cb7-138"><a href="#cb7-138" aria-hidden="true" tabindex="-1"></a>qs.plots.monthly_heatmap(portfolio_dynamic)</span>
<span id="cb7-139"><a href="#cb7-139" aria-hidden="true" tabindex="-1"></a>qs.plots.histogram(portfolio_dynamic)</span>
<span id="cb7-140"><a href="#cb7-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-141"><a href="#cb7-141" aria-hidden="true" tabindex="-1"></a><span class="co"># 4.3 Génération du rapport statistique</span></span>
<span id="cb7-142"><a href="#cb7-142" aria-hidden="true" tabindex="-1"></a>qs.reports.metrics(portfolio_dynamic, benchmark<span class="op">=</span>benchmark)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>[*********************100%***********************]  30 of 30 completed
[**********************50%                       ]  15 of 30 completed</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Actifs retenus après contrôle qualité (30): ['AAPL', 'ABBV', 'ABT', 'ADBE', 'AMZN', 'AVGO', 'BAC', 'COST', 'CRM', 'CVX', 'GOOGL', 'HD', 'INTC', 'JPM', 'KO', 'LLY', 'MCD', 'META', 'MRK', 'MSFT', 'NFLX', 'NVDA', 'PEP', 'PG', 'TMO', 'TSLA', 'UNH', 'V', 'WMT', 'XOM']</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>[*********************100%***********************]  30 of 30 completed
[*********************100%***********************]  1 of 1 completed
/opt/miniconda3/envs/myenv/lib/python3.12/site-packages/pypfopt/efficient_frontier/efficient_frontier.py:259: UserWarning: max_sharpe transforms the optimization problem so additional objectives may not work as expected.
  warnings.warn(
/opt/miniconda3/envs/myenv/lib/python3.12/site-packages/pypfopt/efficient_frontier/efficient_frontier.py:259: UserWarning: max_sharpe transforms the optimization problem so additional objectives may not work as expected.
  warnings.warn(
/opt/miniconda3/envs/myenv/lib/python3.12/site-packages/pypfopt/efficient_frontier/efficient_frontier.py:259: UserWarning: max_sharpe transforms the optimization problem so additional objectives may not work as expected.
  warnings.warn(
/opt/miniconda3/envs/myenv/lib/python3.12/site-packages/pypfopt/efficient_frontier/efficient_frontier.py:259: UserWarning: max_sharpe transforms the optimization problem so additional objectives may not work as expected.
  warnings.warn(
/opt/miniconda3/envs/myenv/lib/python3.12/site-packages/pypfopt/efficient_frontier/efficient_frontier.py:259: UserWarning: max_sharpe transforms the optimization problem so additional objectives may not work as expected.
  warnings.warn(
/opt/miniconda3/envs/myenv/lib/python3.12/site-packages/pypfopt/efficient_frontier/efficient_frontier.py:259: UserWarning: max_sharpe transforms the optimization problem so additional objectives may not work as expected.
  warnings.warn(
/opt/miniconda3/envs/myenv/lib/python3.12/site-packages/pypfopt/efficient_frontier/efficient_frontier.py:259: UserWarning: max_sharpe transforms the optimization problem so additional objectives may not work as expected.
  warnings.warn(
/opt/miniconda3/envs/myenv/lib/python3.12/site-packages/pypfopt/efficient_frontier/efficient_frontier.py:259: UserWarning: max_sharpe transforms the optimization problem so additional objectives may not work as expected.
  warnings.warn(
/opt/miniconda3/envs/myenv/lib/python3.12/site-packages/pypfopt/efficient_frontier/efficient_frontier.py:259: UserWarning: max_sharpe transforms the optimization problem so additional objectives may not work as expected.
  warnings.warn(
/opt/miniconda3/envs/myenv/lib/python3.12/site-packages/pypfopt/efficient_frontier/efficient_frontier.py:259: UserWarning: max_sharpe transforms the optimization problem so additional objectives may not work as expected.
  warnings.warn(
/opt/miniconda3/envs/myenv/lib/python3.12/site-packages/pypfopt/efficient_frontier/efficient_frontier.py:259: UserWarning: max_sharpe transforms the optimization problem so additional objectives may not work as expected.
  warnings.warn(
/opt/miniconda3/envs/myenv/lib/python3.12/site-packages/pypfopt/efficient_frontier/efficient_frontier.py:259: UserWarning: max_sharpe transforms the optimization problem so additional objectives may not work as expected.
  warnings.warn(</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
=== Rapport de nettoyage des données ===
Vérification des index dupliqués avant nettoyage :
Nombre d'index dupliqués dans le Portfolio : 6
Nombre d'index dupliqués dans le Benchmark : 0

Dates des index dupliqués :
DatetimeIndex(['2022-07-05', '2023-04-04', '2023-04-05', '2023-07-05',
               '2024-04-03', '2024-04-04'],
              dtype='datetime64[ns]', name='Date', freq=None)

Vérification après nettoyage :
Nombre de points de données Portfolio : 686
Nombre de points de données Benchmark : 686
Période d'analyse : du 2022-04-04 00:00:00 au 2024-12-30 00:00:00</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Projet_Black-Litterman_files/figure-html/cell-5-output-5.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Projet_Black-Litterman_files/figure-html/cell-5-output-6.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/opt/miniconda3/envs/myenv/lib/python3.12/site-packages/quantstats/_plotting/core.py:699: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.
  ax.legend(fontsize=11)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Projet_Black-Litterman_files/figure-html/cell-5-output-8.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Projet_Black-Litterman_files/figure-html/cell-5-output-9.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/opt/miniconda3/envs/myenv/lib/python3.12/site-packages/quantstats/_plotting/core.py:699: UserWarning: No artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument.
  ax.legend(fontsize=11)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Projet_Black-Litterman_files/figure-html/cell-5-output-11.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Projet_Black-Litterman_files/figure-html/cell-5-output-12.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Projet_Black-Litterman_files/figure-html/cell-5-output-13.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>                    Benchmark    Strategy
------------------  -----------  ----------
Start Period        2022-04-04   2022-04-04
End Period          2024-12-30   2024-12-30
Risk-Free Rate      0.0%         0.0%
Time in Market      100.0%       100.0%

Cumulative Return   27.47%       63.73%
CAGR﹪              6.3%         13.21%

Sharpe              0.61         0.98
Prob. Sharpe Ratio  84.09%       94.75%
Sortino             0.86         1.44
Sortino/√2          0.61         1.02
Omega               1.18         1.18

Max Drawdown        -23.91%      -17.44%
Longest DD Days     617          201

Gain/Pain Ratio     0.11         0.18
Gain/Pain (1M)      0.52         0.93

Payoff Ratio        0.98         0.97
Profit Factor       1.11         1.18
Common Sense Ratio  1.16         1.19
CPC Index           0.57         0.62
Tail Ratio          1.05         1.0
Outlier Win Ratio   3.78         3.07
Outlier Loss Ratio  4.26         3.48

MTD                 -2.08%       -8.67%
3M                  2.94%        -8.14%
6M                  8.18%        -3.86%
YTD                 23.84%       13.78%
1Y                  23.84%       13.78%
3Y (ann.)           6.3%         13.21%
5Y (ann.)           6.3%         13.21%
10Y (ann.)          6.3%         13.21%
All-time (ann.)     6.3%         13.21%

Avg. Drawdown       -1.9%        -4.19%
Avg. Drawdown Days  25           32
Recovery Factor     1.18         3.16
Ulcer Index         0.1          0.07
Serenity Index      0.16         0.77</code></pre>
</div>
</div>
</section>
<section id="passage-dun-modèle-statique-à-un-modèle-dynamique" class="level2">
<h2 class="anchored" data-anchor-id="passage-dun-modèle-statique-à-un-modèle-dynamique">7. Passage d’un modèle statique à un modèle dynamique</h2>
<p>Le passage du modèle Black-Litterman statique à une version dynamique a permis une nette amélioration de la performance globale du portefeuille. Alors que le modèle statique repose sur un unique jeu de vues et une allocation figée dans le temps, l’approche dynamique mise en œuvre dans cette étude repose sur un rééquilibrage trimestriel, une actualisation continue des vues en fonction de la volatilité observée, ainsi qu’un mécanisme explicite de contrôle du drawdown maximal. Par ailleurs, l’objectif d’optimisation a été modifié : la maximisation du ratio de Sharpe a été remplacée par une <strong>minimisation de la volatilité</strong>, jugée plus adaptée à une gestion rigoureuse du risque.</p>
<p>Les résultats chiffrés attestent de l’efficacité de ce changement de paradigme. Sur la période 2022–2024, le portefeuille dynamique génère un rendement cumulé de <strong>63.73 %</strong>, contre <strong>27.47 %</strong> pour l’indice S&amp;P 500. Le <strong>taux de croissance annualisé (CAGR)</strong> atteint <strong>13.21 %</strong>, soit plus du double de celui du benchmark. Le <strong>ratio de Sharpe</strong> ressort à <strong>0.98</strong>, contre <strong>0.61</strong> pour le marché, et le <strong>Sortino ratio</strong> s’élève à <strong>1.44</strong>, traduisant une bonne gestion du risque à la baisse.</p>
<p>Du point de vue du risque, le <strong>drawdown maximal</strong> du portefeuille est limité à <strong>−17.44 %</strong>, inférieur à celui du benchmark (−23.91 %). Le <strong>recovery factor</strong>, indicateur de la capacité à revenir à un niveau de performance après une perte, s’établit à <strong>3.16</strong>, contre <strong>1.18</strong> pour le S&amp;P 500. L’<strong>Ulcer Index</strong>, qui mesure la gravité et la durée des pertes, est également plus faible dans le cas du portefeuille dynamique.</p>
<p>Ces résultats numériques sont confirmés par les visualisations associées. Le graphique des rendements cumulés met en évidence une nette surperformance du portefeuille dynamique par rapport au benchmark, notamment à partir du second semestre 2023. Cette évolution traduit la capacité du modèle à capter la tendance haussière tout en maîtrisant l’exposition au risque.</p>
<p>Le graphique des drawdowns confirme également l’intérêt du modèle dynamique, dans la mesure où les pertes maximales observées sont sensiblement plus contenues. Le portefeuille n’a jamais franchi le seuil critique de −30 %, grâce au mécanisme de filtrage intégré.</p>
<p>La série temporelle du ratio de Sharpe roulant indique que la stratégie dynamique parvient à maintenir un rendement ajusté au risque supérieur à celui du marché sur une grande partie de la période. Cela souligne l’efficacité du rééquilibrage périodique et des vues adaptatives dans la stabilisation du couple rendement/risque.</p>
<p>L’évolution du bêta roulant révèle une sensibilité globalement alignée avec le marché, tout en permettant ponctuellement une certaine décorrélation. Cela témoigne de la capacité du portefeuille à offrir une diversification pertinente, même dans des phases de marché tendues.</p>
<p>Enfin, la volatilité roulante du portefeuille est inférieure à celle du benchmark sur la plupart des sous-périodes analysées. Cette stabilité s’explique par l’utilisation de l’objectif <code>min_volatility()</code> lors de l’optimisation, qui permet d’écarter les configurations extrêmes. La représentation sous forme de carte thermique des rendements mensuels montre par ailleurs une régularité appréciable, avec une fréquence élevée de mois positifs et des pertes mensuelles bien maîtrisées.</p>
<p>En somme, la version dynamique du modèle Black-Litterman s’avère significativement plus performante, plus stable et plus résiliente que sa version statique. Elle combine rigueur mathématique, capacité d’adaptation aux conditions de marché, et discipline de gestion du risque, offrant ainsi une solution particulièrement adaptée à une gestion active fondée sur des principes quantitatifs solides.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Ce projet a permis d’explorer en profondeur le modèle d’allocation Black-Litterman, en commençant par sa version théorique statique, avant d’évoluer vers une mise en œuvre dynamique, plus adaptée aux exigences d’une gestion de portefeuille contemporaine. Dans un premier temps, la structure du modèle a été revisitée à travers les fondements bayésiens de l’intégration des vues de l’investisseur dans les rendements attendus du marché. Ce cadre offre un compromis rigoureux entre données de marché (priors) et opinions subjectives, tout en assurant la cohérence avec l’équilibre global des actifs.</p>
<p>Cependant, l’analyse empirique sur un portefeuille initial à quatre actifs a rapidement mis en lumière les limites de cette approche lorsqu’elle reste figée dans le temps. En réponse, une extension dynamique du modèle a été développée. Celle-ci intègre un univers élargi à 30 actions du S&amp;P 500, un mécanisme de rééquilibrage trimestriel, des vues adaptatives fondées sur la volatilité, ainsi qu’un contrôle explicite du risque via un seuil de drawdown maximal. L’objectif d’optimisation a également été modifié, passant de la maximisation du ratio de Sharpe à la minimisation de la volatilité.</p>
<p>Les résultats sont sans appel. Le modèle dynamique génère un rendement cumulé de <strong>+63.73 %</strong> entre 2022 et 2024, contre <strong>+27.47 %</strong> pour le S&amp;P 500. Il affiche un <strong>CAGR de 13.21 %</strong>, un <strong>ratio de Sharpe de 0.98</strong>, et un <strong>drawdown maximal de −17.44 %</strong>, tout en maintenant une excellente stabilité intertemporelle. Ces performances sont appuyées par une série de visualisations détaillées qui mettent en évidence une surperformance régulière, un meilleur profil de risque, ainsi qu’une résilience marquée dans les phases de marché défavorables.</p>
<p>En définitive, cette étude confirme la pertinence et la flexibilité du modèle Black-Litterman lorsqu’il est adapté à une logique dynamique et contra-cyclique. Il constitue une base solide pour la mise en œuvre d’une gestion quantitative active, et ouvre la voie à des extensions futures, notamment l’intégration de facteurs ESG, l’automatisation du calibrage des vues, ou encore l’utilisation de méthodes bayésiennes hiérarchiques pour affiner les prévisions.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>